# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

```
db.currentOp().inprog.forEach(function(op) {if(op.secs_running > 3) printjson(op);})

...
"opid": 123456789,
...

db.killOp(123456789)
```


```
db.runCommand( { distinct: "collection",
                 key: "city",
                 maxTimeMS: 45 } )
```
## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL.
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

```
0) все ли ноды доступны, если кластер ?
1) maxmemory - сколько RAM отдать под хранение в Redis. 
2) maxmemory-policy - политика переполнения.
3) Читаем логи на предмет ошибок конфигурации и подсказок по их устранению.
4) Внимательно смотрим метрики.
5) Каков процент хранилища Redis'а свободен? 
6) Нет ли свопинга памяти, выделенной Redis`у?
7) Нет ли запущенных медленных операций на Redis`е?
```

## Задача 3

Перед выполнением задания познакомьтесь с документацией по [Common Mysql errors](https://dev.mysql.com/doc/refman/8.0/en/common-errors.html).

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

```
0) А сервис то жив?
1) Анализ логов `mysql.log`. Если произошла не хватка ресурсов хоста, то высвобождать, оптимизировать конфиг, распределять нагрузку. 
2) также еще стоит проверить повреждение файловв `/usr/sbin/mysqld`. Например, сделать memtest. 
3) пересоздать индексы
4) увеличить таймаут на выполнение запроса `connect_timeout`. Посмотреть, если поможет то кривой запрос. как вариант сменить движок =).
```

## Задача 4

Перед выполнением задания ознакомтесь со статьей [Common PostgreSQL errors](https://www.percona.com/blog/2020/06/05/10-common-postgresql-errors/) из блога Percona.

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

Это значит что кончилась память, и чтобы избежать сбоя ядра, процесс Postgres был убит. 
Это значит что кончилась RAM и SWAP память. Нужно посмотреть как расходуется память, возможно
что есть другие процессы, которые потребляют непредвиденно больше памяти. Если дело в Postgres, то оценить его состояние. Стоит начать с кол-ва активных подключений, сразу посмотреть
кол-во долго выполняемых транзакций (зависших). Посмотреть на каком запросе заканчивается память. Вдруг запрос пытается выгрузить данные, превышающие память. Надо высвобождать ресурсы, прибивать
зависшие транзакции, оптимизировать запрос. Например, сделать пагинацию через offset и limit, либо по условию на какую либо колонку. Ну и последнее - увеличивать память, если по остальным пунктам нет вопросов.
советуют выставить переменную ядра `vm.overcommit_memory` в значение, равное `2`. В этом случае ядро не будет резервировать больше памяти, чем указано в параметре `overcommit_ratio`
А в `overcommit_ratio` указывается максимальный процент процент памяти, для которого допустимо избыточное резервирование. Если для него нет места, память не выделяется, в резервировании будет отказано. Это самый безопасный вариант, рекомендованный для PostgreSQL
Соответственно, при правильно подобранных настройках, программы будут получать разумные объёмы имеющейся памяти и `oom-killer`у вмешиваться почти не придётся


